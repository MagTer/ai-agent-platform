# Continuous Integration

CI is provided by a single GitHub Actions workflow (`.github/workflows/ci.yml`).
The workflow executes on every push and pull request targeting `main`.

## Jobs

1. **Lint**
   - Installs dependencies with `poetry install --no-interaction`.
   - Runs `poetry run ruff check .`.
2. **Test**
   - Reuses the Poetry installation from the lint job via the actions cache.
   - Executes `poetry run coverage run -m pytest` followed by `poetry run coverage report` to capture coverage metrics alongside the test results.

Both jobs run on `ubuntu-latest`. Failing lint or test steps block merges.

## Local Validation

Before pushing, run:

```
poetry run ruff check .
poetry run coverage run -m pytest
poetry run coverage report
```

For formatting parity, also run `poetry run black .` locally even though the
workflow only enforces linting. This keeps CI fast while preserving formatting
standards.

## How we track test coverage

Coverage is gathered with `coverage.py` and configured via `pyproject.toml` to
measure both line and branch coverage for modules under `src/`. The CI workflow
runs `poetry run coverage run -m pytest` followed by `poetry run coverage report`
so every pull request displays the latest totals.

Locally, you can replicate the report with:

```
poetry run coverage run -m pytest
poetry run coverage report
```

For a navigable HTML view, run `poetry run coverage html` and open
`htmlcov/index.html` in your browser. Coverage numbers are provided to inform
test gaps, not to enforce 100% coverage. Focus on meaningful scenarios that
improve confidence instead of chasing the metric.
