# Continuous Integration Pipeline

The GitHub Actions workflow defined in [`.github/workflows/ci.yml`](../../.github/workflows/ci.yml)
validates every push to `main`, branches that match the delivery model patterns, and all pull
requests. Each job runs on `ubuntu-latest`, uses Python 3.11, and caches a project-scoped Poetry
virtual environment (`.venv`) together with the Poetry and pip caches keyed by `poetry.lock` and
`pyproject.toml`.

## Quality Gate job

The **Quality Gate** job is the primary blocker for merges. After restoring dependencies with
`poetry install --no-interaction`, it executes the tooling suite below in order. The job stops at the
first failure, so a red status on any step fails the pull request.

| Step | Command | Purpose | Pass/Fail behaviour |
| --- | --- | --- | --- |
| Ruff | `poetry run ruff check .` | Static analysis and linting. | Any diagnostic exits non-zero and fails the job. |
| Black | `poetry run black --check .` | Ensures code formatting compliance. | Formatting drift causes a non-zero exit and fails the job. |
| Pytest | `poetry run pytest` | Executes the test suite. | Any failing test produces a non-zero exit and fails the job. |
| Dependency freshness | `poetry run python scripts/deps_check.py --quiet` | Detects outdated Poetry dependencies. | Exit code `0` passes. Exit code `4` indicates a tooling failure and fails the job. Other non-zero codes surface as workflow warningsâ€”your pull request still passes, but you must address the flagged upgrades before completion. |

### Contributor checklist

Before requesting review, reproduce the quality gate locally to avoid surprises:

1. `poetry install --no-interaction`
2. `poetry run ruff check .`
3. `poetry run black --check .`
4. `poetry run pytest`
5. `poetry run python scripts/deps_check.py`

A task is **only complete** when every command above succeeds without errors. If the dependency
check reports upgrades, resolve them or explain the plan in your pull request before marking the
work as ready.

## Compose configuration job

The **Compose config** job runs after the Quality Gate succeeds. It copies `.env.template` to `.env`
and validates the Docker Compose definition:

```bash
docker compose -f docker-compose.yml config
```

This protects the local developer experience by catching configuration regressions that would break
container orchestration.
