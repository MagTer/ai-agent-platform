"""Shared domain models for the AI Agent Platform."""

from __future__ import annotations

from datetime import UTC, datetime
from enum import Enum
from typing import Any, Literal

from pydantic import BaseModel, Field


class RoutingDecision(str, Enum):
    FAST_PATH = "FAST_PATH"
    CHAT = "CHAT"
    AGENTIC = "AGENTIC"


class AgentMessage(BaseModel):
    """Representation of a chat message exchanged with the agent."""

    role: str = Field(description="Chat role such as 'user', 'assistant', 'system' or 'tool'.")
    content: str | None = Field(
        default=None, description="Natural language content of the message."
    )
    name: str | None = Field(default=None, description="Name of the author (for tool messages).")
    tool_calls: list[dict[str, Any]] | None = Field(
        default=None, description="Tool calls generated by the assistant."
    )
    tool_call_id: str | None = Field(
        default=None, description="ID of the tool call this message responds to."
    )


class AgentRequest(BaseModel):
    """Inbound request payload for the agent endpoint."""

    prompt: str = Field(description="Latest user prompt to process.")
    conversation_id: str | None = Field(
        default=None,
        description="Optional conversation identifier to preserve context across calls.",
    )
    metadata: dict[str, Any] | None = Field(
        default=None, description="Arbitrary metadata forwarded to the orchestrator."
    )
    messages: list[AgentMessage] | None = Field(
        default=None,
        description=(
            "Optional explicit conversation history to seed the prompt. When provided "
            "the state store history is ignored for this call."
        ),
    )


class PlanStep(BaseModel):
    """Structured instruction for orchestrating the prompt lifecycle."""

    id: str = Field(description="Unique identifier for the plan step.")
    label: str = Field(description="Human-readable label describing the step.")
    executor: Literal["agent", "litellm", "remote"] = Field(
        description="Indicates which execution context runs the step."
    )
    action: Literal["memory", "tool", "completion"] = Field(
        description="Semantic action performed by the step."
    )
    tool: str | None = Field(default=None, description="Tool referenced by this step (if any).")
    args: dict[str, Any] = Field(
        default_factory=dict, description="Optional arguments consumed by the step."
    )
    description: str | None = Field(
        default=None, description="Additional context the planner wanted to capture."
    )
    provider: str | None = Field(
        default=None,
        description="Override provider identifier when the step reaches a remote LLM.",
    )


class Plan(BaseModel):
    """Planner output injected into response metadata for observability."""

    steps: list[PlanStep] = Field(
        default_factory=list,
        description="Ordered list of directives that the agent service consumes sequentially.",
    )
    description: str | None = Field(
        default=None, description="Optional summary text produced by the planner."
    )


class AgentResponse(BaseModel):
    """Response payload returned to the caller."""

    conversation_id: str = Field(description="Conversation identifier used for follow-up calls.")
    response: str = Field(description="Assistant completion text.")
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    messages: list[AgentMessage] = Field(
        default_factory=list,
        description="Messages used to assemble the final prompt for observability.",
    )
    steps: list[dict[str, Any]] = Field(
        default_factory=list,
        description=(
            "Structured orchestration trace describing memory lookups, tool invocations, "
            "and LLM calls performed while answering the prompt."
        ),
    )
    metadata: dict[str, Any] = Field(default_factory=dict)


class HealthStatus(BaseModel):
    """Lightweight health payload for monitoring."""

    status: str = Field(default="ok")
    detail: str | None = None


class StepResult(BaseModel):
    """Result of a single plan step execution."""

    step: PlanStep
    status: str
    result: dict[str, Any] = Field(default_factory=dict)
    messages: list[AgentMessage] = Field(default_factory=list)


__all__ = [
    "AgentMessage",
    "AgentRequest",
    "AgentResponse",
    "Plan",
    "PlanStep",
    "HealthStatus",
    "StepResult",
    "RoutingDecision",
]
